\documentclass[10pt]{article}
\usepackage{color}
\usepackage{graphicx} % Required for inserting 
%%\usepackage{algpseudocode} % Include the package for algorithmic environment
\usepackage{algorithm}
\usepackage{booktabs} % For better-quality horizontal lines
\usepackage{algpseudocode}
\usepackage{multirow}
\usepackage{threeparttable} % For table notes
\usepackage{array} % For table formatting

\usepackage{setspace}
\usepackage{float} % add this in your preamble
\usepackage{amsmath}
\usepackage{tabularx}

\usepackage[round]{natbib}

\usepackage{multirow}
\usepackage{fourier} 
\usepackage{booktabs}
\usepackage{array}
\usepackage{makecell}
\usepackage[font={small,it}]{caption}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{tabstackengine}
\usepackage[toc,page]{appendix}
\usepackage{graphicx, fullpage, verbatim, amsmath}
\usepackage{url, amsfonts, amssymb, amsthm,color, enumerate}
\usepackage{placeins, listings, textcomp, mathtools, multicol, tikz}
\usepackage{dsfont}
\usepackage{amsfonts}
\usepackage{bm}



\TABstackMath

\doublespacing
% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{graphicx}
\bibliographystyle{apalike}
\usepackage[colorlinks=true,citecolor=blue]{hyperref}
\newcommand\choleraDeath{\delta_{C}}

% Using \doublespacing in the preamble 
% changes the text to double-line spacing
\doublespacing


\begin{document}

{\Large
\textbf\newline{Poisson Approximate Likelihood compared to the particle filter} 
}
\newline

\begin{abstract}
Recently, a novel approach (Poisson Approximate Likelihood, PAL) was introduced by \cite{wwr}, which employs a Poisson approximation to posterior densities, offering a fast and consistent approximation for the likelihood function for compatible POMP models. \cite{wwr} claimed that their method, along with its associated model, improved the maximum likelihood estimation compared to traditional sequential Monte Carlo (SMC) methods used in \cite{stocks} when applied to the German rotavirus, by approximately 3200 log-likelihood units (see Table 1. \cite{wwr}). However, our analysis of comparing two methods applied to the model for the same rotavirus dataset reveals that the improvement of 3200 log-likelihood units results from the use of two different datasets differed by a scaling factor. In simulations for a correctly specified model, a standard particle filter log-likelihood estimate, optimized using iteratered filtering, outperforms PAL. For the rotavirus data, once a poor specification of initial values is fixed and the same data are used for both methods, the particle filter also outperforms PAL. 
\end{abstract}


% R starts here

<<setup,echo=FALSE,message=FALSE,warning=FALSE>>=
rm(list = ls())     # clear objects

library("knitr")
opts_knit$set(concordance=TRUE)
opts_chunk$set(
    concordance = TRUE,
    tidy = TRUE,
    message = FALSE,
    warning = FALSE,
    tidy.opts = list(
        keep.blank.line = FALSE
    ),
    comment = "",
    echo = FALSE,
    results = FALSE,
    dev.args = list(
        bg = "transparent",
        pointsize = 9
    ),
    fig.path = "figure/"
)

myround <- function(x, digits = 1) {
  # taken from the broman package
  if (digits < 1)
    stop("This is intended for the case digits >= 1.")
  if (length(digits) > 1) {
    digits <- digits[1]
    warning("Using only digits[1]")
  }
  tmp <- sprintf(paste("%.", digits, "f", sep = ""), x)
  zero <- paste0("0.", paste(rep("0", digits), collapse = ""))
  tmp[tmp == paste0("-", zero)] <- zero
  tmp
}

graphics.off()      # close graphics windows
library(pomp)
library(magrittr)
library(plyr)
library(reshape2)
library(ggplot2)
library(scales)
library(foreach)
library(doParallel)
registerDoParallel()
stopifnot(packageVersion("pomp") >= "1.7")

RUN_LEVEL = 1
NP_MIF       = switch(RUN_LEVEL, 4, 50000)
NMIF         = switch(RUN_LEVEL, 4,  100)
ncores       = switch(RUN_LEVEL, 4,  36)
@


% OvOv model is here

<<OvOv-model>>=
# measurement model 
dmeas <- Csnippet("
                  if (ISNA(cases1)) {
                  lik = (give_log) ? 0 : 1;
                  } else {
                        lik =  dbinom(cases1, H1, q1, 1) +
                        dbinom(cases2, H2, q2, 1) +
                        dbinom(cases3, H3, q3, 1);
                      
                    lik = (give_log) ? lik : exp(lik);
                        
                    }")
rmeas <-  Csnippet("
                    cases1 = rbinom(H1, q1);
                    cases2 = rbinom(H2, q2);
                    cases3 = rbinom(H3, q3);
                  ")



rproc <- Csnippet("
    int I = I1 + I2 + I3;
    int trans_S1[3], trans_S2[3], trans_S3[2], trans_I1[3], trans_I2[3], trans_I3[2], trans_R1[3], trans_R2[3], trans_R3[2];
    
    double prob_S1[3],prob_I1[3],prob_R1[3],prob_S2[3],prob_I2[3],prob_R2[3],prob_S3[2],prob_I3[2],prob_R3[2];
    
    double xi = rgamma(sigma_xi, 1/sigma_xi);
    
    double kappa = (1 + beta11*cos(2*3.141593*t/52 + phi)) * xi;
    
    // Define rate
    prob_S1[0] = 1-exp(-dt*beta1*kappa*I/N); // 0->1
    prob_S1[1] = 1-exp(-delta1*dt);
    prob_S1[2] = exp(-delta1*dt) + exp(-dt*beta1*kappa*I/N) - 1;
    
    prob_I1[0] = 1-exp(-gamma*dt);
    prob_I1[1] = 1-exp(-delta1*dt);
    prob_I1[2] = exp(-gamma*dt)+exp(-delta1*dt) - 1;
    
    prob_R1[0] = 1 - exp(-omega*dt);  // E_1,t this goes back to S_1,(t+1)
    prob_R1[1] = 1 - exp(-delta1*dt);
    prob_R1[2] = exp(-omega*dt) + exp(-delta1*dt) - 1;
    
    prob_S2[0] = 1-exp(-dt*beta2*kappa*I/N);
    prob_S2[1] = 1-exp(-delta2*dt);
    prob_S2[2] = exp(-delta2*dt) + exp(-dt*beta2*kappa*I/N) - 1;
    
    prob_I2[0] = 1-exp(-dt*gamma);
    prob_I2[1] = 1-exp(-dt*delta2);
    prob_I2[2] = exp(-dt*gamma)+exp(-dt*delta2) - 1;
    
    prob_R2[0] = 1 - exp(-dt*omega);  // E_1,t this goes back to S_1,(t+1)
    prob_R2[1] = 1 - exp(-dt*delta2);
    prob_R2[2] = exp(-dt*omega) + exp(-dt*delta2) - 1;
    
    // For Age Group (3): Die first before transition;
    
    int S3mD, I3mD, R3mD;
    
    S3mD = rbinom(S3, 1-dt*mu); // S3 minus Death: mu is the death rate, so it's 1-mu here
    I3mD = rbinom(I3, 1-dt*mu);
    R3mD = rbinom(R3, 1-dt*mu);
    
    prob_S3[0] = 1-exp(-dt*beta3*kappa*I/N);
    prob_S3[1] = exp(-dt*beta3*kappa*I/N);
    
    prob_I3[0] = 1 - exp(-dt*gamma);
    prob_I3[1] = exp(-dt*gamma);
    
    prob_R3[0] = 1 - exp(-dt*omega);
    prob_R3[1] = exp(-dt*omega);
    
    // Transition
    // B: S->I
    // C: I->R
    // F: Aging: (1)->(2)->(3)
    // E: R->S
    // D: Death
    //// Note: Here S_1, S_2... are all old value from (t-1)
    rmultinom(S1, &prob_S1, 3, &trans_S1); // B, F, S-B-F
    rmultinom(I1, &prob_I1, 3, &trans_I1); // C, F, I-C-F
    rmultinom(R1, &prob_R1, 3, &trans_R1); // E, F, R-E-F
    
    rmultinom(S2, &prob_S2, 3, &trans_S2); // B, F, S-B-F
    rmultinom(I2, &prob_I2, 3, &trans_I2); // C, F, I-C-F
    rmultinom(R2, &prob_R2, 3, &trans_R2); // E, F, R-E-F
    
    rmultinom(S3mD, &prob_S3, 2, &trans_S3); // B, (S-D)-B
    rmultinom(I3mD, &prob_I3, 2, &trans_I3); // C, (I-D)-C
    rmultinom(R3mD, &prob_R3, 2, &trans_R3); // E, (R-D)-E
    
    S1 = trans_S1[2] + trans_R1[0] + rpois(4*1025.7); // Include Birth
    I1 = trans_I1[2] + trans_S1[0];
    R1 = trans_R1[2] + trans_I1[0];
    
    S2 = trans_S2[2] + trans_R2[0] + trans_S1[1]; // Include Aging
    I2 = trans_I2[2] + trans_S2[0] + trans_I1[1];
    R2 = trans_R2[2] + trans_I2[0] + trans_R1[1];
    
    S3 = trans_S3[1] + trans_R3[0] + trans_S2[1]; // Include Aging
    I3 = trans_I3[1] + trans_S3[0] + trans_I2[1];
    R3 = trans_R3[1] + trans_I3[0] + trans_R2[1];
    
    //Accumvar
    H1 += trans_S1[0];
    H2 += trans_S2[0];
    H3 += trans_S3[0];
    
    q1 = -1; 
    while(q1 < 0 || q1 > 1){
      q1 = rnorm(0.07, sigma_q);
    }
    
    q2 = -1; 
    while(q2 < 0 || q2 > 1){
      q2 = rnorm(0.07, sigma_q);
    }
    
    q3 = -1; 
    while(q3 < 0 || q3 > 1){
      q3 = rnorm(0.07, sigma_q);
    }
")


# define parameters (without betas)
params_fixed <- c(gamma=1, delta1=1/(5*52),delta2=1/(55*52), alpha=1/(78.86912*52), 
                  mu=0, N=82372825, omega=1/(1*52))
# WWR's rinit
rinit <- Csnippet("
    double m = N/(S10+I10+R10+S20+I20+R20+S30+I30+R30);
    I1=nearbyint(m*I10);
    I2=nearbyint(m*I20);
    I3=nearbyint(m*I30);
    S1=nearbyint(m*S10);
    S2=nearbyint(m*S20);
    S3=nearbyint(m*S30);
    R1=nearbyint(m*R10);
    R2=nearbyint(m*R20);
    R3=nearbyint(m*R30);
    H1 = 0;
    H2 = 0;
    H3 = 0;
")

# Set to MLE
params_stocks_stst_mle <- params_fixed

params_stocks_stst_mle["beta1"] <- 11.48
params_stocks_stst_mle["beta2"] <- 0.25
params_stocks_stst_mle["beta3"] <- 0.35
params_stocks_stst_mle["phi"] <- 0.14
params_stocks_stst_mle["beta11"] <- 0.16
params_stocks_stst_mle["sigma_q"] <- 0.021
params_stocks_stst_mle["sigma_xi"] <- 66.89
params_stocks_stst_mle["S10"] <- 0.047061
params_stocks_stst_mle["I10"] <- 0.000368
params_stocks_stst_mle["R10"] <- 0.015967
params_stocks_stst_mle["S20"] <- 0.015967
params_stocks_stst_mle["I20"] <- 0.000011
params_stocks_stst_mle["R20"] <- 0.003677
params_stocks_stst_mle["S30"] <- 0.237624
params_stocks_stst_mle["I30"] <- 0.000031
params_stocks_stst_mle["R30"] <- 0.001591
@


% Maximization Round 1

<<maximization1>>=
pt <- pomp::parameter_trans(
  log = c("beta1","beta2","beta3","sigma_q","sigma_xi"),
  logit=c("beta11"),
  barycentric=c("S10","I10","R10",
                "S20","I20","R20",
                "S30","I30","R30"),
  toEst= pomp::Csnippet("T_phi = logit(phi/(M_2PI));"),
  fromEst= pomp::Csnippet("phi = M_2PI*expit(T_phi);")
)

read.table("real_rotavirus_metadata.txt") %>%
  rbind(data.frame(time=0,cases1=NA,cases2=NA,cases3=NA)) %>%
  arrange(time) -> dat


pomp(data = dat,
     times="time",
     t0=0,
     dmeasure = dmeas,
     rmeasure = rmeas,
     rprocess = discrete_time(step.fun = rproc, delta.t = 1/4),
     statenames = c("S1", "I1", "R1", "H1", 
                    "S2", "I2", "R2", "H2",
                    "S3", "I3", "R3", "H3", 
                    "q1", "q2", "q3"),
     paramnames = names(params_stocks_stst_mle),
     accumvars=c("H1", "H2", "H3"),
     rinit=rinit,
     partrans = pt,
     params = params_stocks_stst_mle
) -> sir

sir_panel <- panelPomp::panelPomp(list(unit1=sir),
                                  shared=NULL,
                                  specific=params_stocks_stst_mle |> 
                                    as.matrix() |>
                                    `colnames<-`("unit1")
)

require(doParallel)
cores <- ncores
registerDoParallel(cores)
mcopts <- list(set.seed=TRUE)


sir_box <- rbind(
  beta1=c(10,15),
  beta2=c(0.2,0.4),
  beta3=c(0.3,0.5),
  phi=c(0.01,0.3),
  beta11=c(0.1,0.2),
  sigma_q=c(0.001,0.1),
  sigma_xi=c(65,70),
  S10 = c(0.01,0.05),
  I10 = c(0.0001, 0.0005),
  R10 = c(0.01, 0.05),
  S20 = c(0.01,0.7),
  I20 = c(0.000001,0.00002),
  R20 = c(0.001,0.005),
  S30 = c(0.01,0.5),
  I30 = c(0.000001, 0.0001),
  R30 = c(0.0001,0.005)
)


## Make it panelPomp
c(apply(sir_box,1,function(x)runif(1,min=x[1],max=x[2])),
  params_fixed) |> 
  as.matrix() |>
  `colnames<-`("unit1") -> starting

bake(file = "output/round_01/ovov_mif_01.rds",{ 
  mifs_global <- foreach(i=1:cores,.packages='pomp', .options.multicore=mcopts) %dopar% {
    panelPomp::mif2(
      sir_panel,
      Np = NP_MIF,
      cooling.fraction.50 = 0.5,
      rw.sd = rw_sd(beta1=0.01,beta2=0.01,beta3=0.01,
                    beta11=0.01,phi=0.01,sigma_q=0.01,sigma_xi=0.01,
                    S10=ivp(0.24),I10=ivp(0.24),R10=ivp(0.24),
                    S20=ivp(0.24),I20=ivp(0.24),R20=ivp(0.24),
                    S30=ivp(0.24),I30=ivp(0.24),R30=ivp(0.24)),
      cooling.type = "geometric",
      Nmif = NMIF,
      shared.start = numeric(0),
      specific.start = starting,
      block = F
    ) 
  }
  mifs_global
})

bake(file = "output/round_01/ovov_01_el.rds",{
  el <- measlespkg::eval_logLik(mifs_global, ncores=cores, np_pf = NP_MIF, nreps=cores)
  el
})
@


% Continue: Maximization Round 2

<<maximization2>>=
sd           = 2/3
top_n_fits   = 12
# measurement model 
dmeas <- Csnippet("
                  if (ISNA(cases1)) {
                  lik = (give_log) ? 0 : 1;
                  } else {
                        lik =  dbinom(cases1, H1, q1, 1) +
                        dbinom(cases2, H2, q2, 1) +
                        dbinom(cases3, H3, q3, 1);
                      
                    lik = (give_log) ? lik : exp(lik);
                        
                    }")
rmeas <-  Csnippet("
                    cases1 = rbinom(H1, q1);
                    cases2 = rbinom(H2, q2);
                    cases3 = rbinom(H3, q3);
                  ")



rproc <- Csnippet("
    int I = I1 + I2 + I3;
    int trans_S1[3], trans_S2[3], trans_S3[2], trans_I1[3], trans_I2[3], trans_I3[2], trans_R1[3], trans_R2[3], trans_R3[2];
    
    double prob_S1[3],prob_I1[3],prob_R1[3],prob_S2[3],prob_I2[3],prob_R2[3],prob_S3[2],prob_I3[2],prob_R3[2];
    
    double xi = rgamma(sigma_xi, 1/sigma_xi);
    
    double kappa = (1 + beta11*cos(2*3.141593*t/52 + phi)) * xi;
    
    // Define rate
    prob_S1[0] = 1-exp(-dt*beta1*kappa*I/N); // 0->1
    prob_S1[1] = 1-exp(-delta1*dt);
    prob_S1[2] = exp(-delta1*dt) + exp(-dt*beta1*kappa*I/N) - 1;
    
    prob_I1[0] = 1-exp(-gamma*dt);
    prob_I1[1] = 1-exp(-delta1*dt);
    prob_I1[2] = exp(-gamma*dt)+exp(-delta1*dt) - 1;
    
    prob_R1[0] = 1 - exp(-omega*dt);  // E_1,t this goes back to S_1,(t+1)
    prob_R1[1] = 1 - exp(-delta1*dt);
    prob_R1[2] = exp(-omega*dt) + exp(-delta1*dt) - 1;
    
    prob_S2[0] = 1-exp(-dt*beta2*kappa*I/N);
    prob_S2[1] = 1-exp(-delta2*dt);
    prob_S2[2] = exp(-delta2*dt) + exp(-dt*beta2*kappa*I/N) - 1;
    
    prob_I2[0] = 1-exp(-dt*gamma);
    prob_I2[1] = 1-exp(-dt*delta2);
    prob_I2[2] = exp(-dt*gamma)+exp(-dt*delta2) - 1;
    
    prob_R2[0] = 1 - exp(-dt*omega);  // E_1,t this goes back to S_1,(t+1)
    prob_R2[1] = 1 - exp(-dt*delta2);
    prob_R2[2] = exp(-dt*omega) + exp(-dt*delta2) - 1;
    
    // For Age Group (3): Die first before transition;
    
    int S3mD, I3mD, R3mD;
    
    S3mD = rbinom(S3, 1-dt*mu); // S3 minus Death: mu is the death rate, so it's 1-mu here
    I3mD = rbinom(I3, 1-dt*mu);
    R3mD = rbinom(R3, 1-dt*mu);
    
    prob_S3[0] = 1-exp(-dt*beta3*kappa*I/N);
    prob_S3[1] = exp(-dt*beta3*kappa*I/N);
    
    prob_I3[0] = 1 - exp(-dt*gamma);
    prob_I3[1] = exp(-dt*gamma);
    
    prob_R3[0] = 1 - exp(-dt*omega);
    prob_R3[1] = exp(-dt*omega);
    
    // Transition
    // B: S->I
    // C: I->R
    // F: Aging: (1)->(2)->(3)
    // E: R->S
    // D: Death
    //// Note: Here S_1, S_2... are all old value from (t-1)
    rmultinom(S1, &prob_S1, 3, &trans_S1); // B, F, S-B-F
    rmultinom(I1, &prob_I1, 3, &trans_I1); // C, F, I-C-F
    rmultinom(R1, &prob_R1, 3, &trans_R1); // E, F, R-E-F
    
    rmultinom(S2, &prob_S2, 3, &trans_S2); // B, F, S-B-F
    rmultinom(I2, &prob_I2, 3, &trans_I2); // C, F, I-C-F
    rmultinom(R2, &prob_R2, 3, &trans_R2); // E, F, R-E-F
    
    rmultinom(S3mD, &prob_S3, 2, &trans_S3); // B, (S-D)-B
    rmultinom(I3mD, &prob_I3, 2, &trans_I3); // C, (I-D)-C
    rmultinom(R3mD, &prob_R3, 2, &trans_R3); // E, (R-D)-E
    
    S1 = trans_S1[2] + trans_R1[0] + rpois(4*1025.7); // Include Birth
    I1 = trans_I1[2] + trans_S1[0];
    R1 = trans_R1[2] + trans_I1[0];
    
    S2 = trans_S2[2] + trans_R2[0] + trans_S1[1]; // Include Aging
    I2 = trans_I2[2] + trans_S2[0] + trans_I1[1];
    R2 = trans_R2[2] + trans_I2[0] + trans_R1[1];
    
    S3 = trans_S3[1] + trans_R3[0] + trans_S2[1]; // Include Aging
    I3 = trans_I3[1] + trans_S3[0] + trans_I2[1];
    R3 = trans_R3[1] + trans_I3[0] + trans_R2[1];
    
    //Accumvar
    H1 += trans_S1[0];
    H2 += trans_S2[0];
    H3 += trans_S3[0];
    
    q1 = -1; 
    while(q1 < 0 || q1 > 1){
      q1 = rnorm(0.07, sigma_q);
    }
    
    q2 = -1; 
    while(q2 < 0 || q2 > 1){
      q2 = rnorm(0.07, sigma_q);
    }
    
    q3 = -1; 
    while(q3 < 0 || q3 > 1){
      q3 = rnorm(0.07, sigma_q);
    }
")


# define parameters (without betas)
params_fixed <- c(gamma=1, delta1=1/(5*52),delta2=1/(55*52), alpha=1/(78.86912*52), 
                  mu=0, N=82372825, omega=1/(1*52))
# WWR's rinit
rinit <- Csnippet("
    double m = N/(S10+I10+R10+S20+I20+R20+S30+I30+R30);
    I1=nearbyint(m*I10);
    I2=nearbyint(m*I20);
    I3=nearbyint(m*I30);
    S1=nearbyint(m*S10);
    S2=nearbyint(m*S20);
    S3=nearbyint(m*S30);
    R1=nearbyint(m*R10);
    R2=nearbyint(m*R20);
    R3=nearbyint(m*R30);
    H1 = 0;
    H2 = 0;
    H3 = 0;
")

# Set to MLE
params_stocks_stst_mle <- params_fixed

params_stocks_stst_mle["beta1"] <- 11.48
params_stocks_stst_mle["beta2"] <- 0.25
params_stocks_stst_mle["beta3"] <- 0.35
params_stocks_stst_mle["phi"] <- 0.14
params_stocks_stst_mle["beta11"] <- 0.16
params_stocks_stst_mle["sigma_q"] <- 0.021
params_stocks_stst_mle["sigma_xi"] <- 66.89
params_stocks_stst_mle["S10"] <- 0.047061
params_stocks_stst_mle["I10"] <- 0.000368
params_stocks_stst_mle["R10"] <- 0.015967
params_stocks_stst_mle["S20"] <- 0.015967
params_stocks_stst_mle["I20"] <- 0.000011
params_stocks_stst_mle["R20"] <- 0.003677
params_stocks_stst_mle["S30"] <- 0.237624
params_stocks_stst_mle["I30"] <- 0.000031
params_stocks_stst_mle["R30"] <- 0.001591



pt <- pomp::parameter_trans(
  log = c("beta1","beta2","beta3","sigma_q","sigma_xi"),
  logit=c("beta11"),
  barycentric=c("S10","I10","R10",
                "S20","I20","R20",
                "S30","I30","R30"),
  toEst= pomp::Csnippet("T_phi = logit(phi/(M_2PI));"),
  fromEst= pomp::Csnippet("phi = M_2PI*expit(T_phi);")
)

read.table("real_rotavirus_metadata.txt") %>%
  rbind(data.frame(time=0,cases1=NA,cases2=NA,cases3=NA)) %>%
  arrange(time) -> dat


pomp(data = dat,
     times="time",
     t0=0,
     dmeasure = dmeas,
     rmeasure = rmeas,
     rprocess = discrete_time(step.fun = rproc, delta.t = 1/4),
     statenames = c("S1", "I1", "R1", "H1", 
                    "S2", "I2", "R2", "H2",
                    "S3", "I3", "R3", "H3", 
                    "q1", "q2", "q3"),
     paramnames = names(params_stocks_stst_mle),
     accumvars=c("H1", "H2", "H3"),
     rinit=rinit,
     partrans = pt,
     params = params_stocks_stst_mle
) -> sir

sir_panel <- panelPomp::panelPomp(list(unit1=sir),
                                  shared=NULL,
                                  specific=params_stocks_stst_mle |> 
                                    as.matrix() |>
                                    `colnames<-`("unit1")
)

require(doParallel)
cores <- ncores
registerDoParallel(cores)
mcopts <- list(set.seed=TRUE)

### Next-round code
el <- readRDS("output/round_01/ovov_01_el.rds")
x <- na.omit(el$fits)
score_total = x$logLik
ranking_total = order(score_total, decreasing = TRUE)[1:top_n_fits]

best_fits = dplyr::select(
  x[ranking_total,], -"logLik", -"se"
)

recycle_vec = sort(rep_len(1:top_n_fits, cores))
full_best_fit <- best_fits[recycle_vec, ] 

coef_names <- colnames(full_best_fit)
colnames(full_best_fit) <- gsub(".{7}$","",coef_names)

starting_values <- vector(cores, mode="list")

for(i in 1:cores){
  t(full_best_fit[i, ])  |> 
    as.matrix() |>
    `colnames<-`("unit1") -> starting_values[[i]] 
}

mifs_global <- foreach(i=1:cores,.packages='pomp', .options.multicore=mcopts) %dopar% {
  panelPomp::mif2(
    sir_panel,
    Np = NP_MIF,
    cooling.fraction.50 = 0.5,
    rw.sd = rw_sd(beta1=0.01*sd,beta2=0.01*sd,beta3=0.01*sd,
                  beta11=0.01*sd,phi=0.01*sd,sigma_q=0.01*sd,sigma_xi=0.01*sd,
                  S10=ivp(0.24)*sd,I10=ivp(0.24)*sd,R10=ivp(0.24)*sd,
                  S20=ivp(0.24)*sd,I20=ivp(0.24)*sd,R20=ivp(0.24)*sd,
                  S30=ivp(0.24)*sd,I30=ivp(0.24)*sd,R30=ivp(0.24)*sd),
    cooling.type = "geometric",
    Nmif = NMIF,
    shared.start = numeric(0),
    specific.start = starting_values[[i]],
    block = F
  ) 
}

bake(file = "output/round_02/ovov_mif_02.rds",{ 
  mifs_global
})

bake(file = "output/round_02/ovov_02_el.rds",{
  el <- measlespkg::eval_logLik(mifs_global, ncores = cores, np_pf = NP_MIF, nreps=cores)
  el
})
@

% Continue: Maximization Round 3

<<maximization3>>=
sd           = (2/3)^2
top_n_fits   = 12
# measurement model 
dmeas <- Csnippet("
                  if (ISNA(cases1)) {
                  lik = (give_log) ? 0 : 1;
                  } else {
                        lik =  dbinom(cases1, H1, q1, 1) +
                        dbinom(cases2, H2, q2, 1) +
                        dbinom(cases3, H3, q3, 1);
                      
                    lik = (give_log) ? lik : exp(lik);
                        
                    }")
rmeas <-  Csnippet("
                    cases1 = rbinom(H1, q1);
                    cases2 = rbinom(H2, q2);
                    cases3 = rbinom(H3, q3);
                  ")



rproc <- Csnippet("
    int I = I1 + I2 + I3;
    int trans_S1[3], trans_S2[3], trans_S3[2], trans_I1[3], trans_I2[3], trans_I3[2], trans_R1[3], trans_R2[3], trans_R3[2];
    
    double prob_S1[3],prob_I1[3],prob_R1[3],prob_S2[3],prob_I2[3],prob_R2[3],prob_S3[2],prob_I3[2],prob_R3[2];
    
    double xi = rgamma(sigma_xi, 1/sigma_xi);
    
    double kappa = (1 + beta11*cos(2*3.141593*t/52 + phi)) * xi;
    
    // Define rate
    prob_S1[0] = 1-exp(-dt*beta1*kappa*I/N); // 0->1
    prob_S1[1] = 1-exp(-delta1*dt);
    prob_S1[2] = exp(-delta1*dt) + exp(-dt*beta1*kappa*I/N) - 1;
    
    prob_I1[0] = 1-exp(-gamma*dt);
    prob_I1[1] = 1-exp(-delta1*dt);
    prob_I1[2] = exp(-gamma*dt)+exp(-delta1*dt) - 1;
    
    prob_R1[0] = 1 - exp(-omega*dt);  // E_1,t this goes back to S_1,(t+1)
    prob_R1[1] = 1 - exp(-delta1*dt);
    prob_R1[2] = exp(-omega*dt) + exp(-delta1*dt) - 1;
    
    prob_S2[0] = 1-exp(-dt*beta2*kappa*I/N);
    prob_S2[1] = 1-exp(-delta2*dt);
    prob_S2[2] = exp(-delta2*dt) + exp(-dt*beta2*kappa*I/N) - 1;
    
    prob_I2[0] = 1-exp(-dt*gamma);
    prob_I2[1] = 1-exp(-dt*delta2);
    prob_I2[2] = exp(-dt*gamma)+exp(-dt*delta2) - 1;
    
    prob_R2[0] = 1 - exp(-dt*omega);  // E_1,t this goes back to S_1,(t+1)
    prob_R2[1] = 1 - exp(-dt*delta2);
    prob_R2[2] = exp(-dt*omega) + exp(-dt*delta2) - 1;
    
    // For Age Group (3): Die first before transition;
    
    int S3mD, I3mD, R3mD;
    
    S3mD = rbinom(S3, 1-dt*mu); // S3 minus Death: mu is the death rate, so it's 1-mu here
    I3mD = rbinom(I3, 1-dt*mu);
    R3mD = rbinom(R3, 1-dt*mu);
    
    prob_S3[0] = 1-exp(-dt*beta3*kappa*I/N);
    prob_S3[1] = exp(-dt*beta3*kappa*I/N);
    
    prob_I3[0] = 1 - exp(-dt*gamma);
    prob_I3[1] = exp(-dt*gamma);
    
    prob_R3[0] = 1 - exp(-dt*omega);
    prob_R3[1] = exp(-dt*omega);
    
    // Transition
    // B: S->I
    // C: I->R
    // F: Aging: (1)->(2)->(3)
    // E: R->S
    // D: Death
    //// Note: Here S_1, S_2... are all old value from (t-1)
    rmultinom(S1, &prob_S1, 3, &trans_S1); // B, F, S-B-F
    rmultinom(I1, &prob_I1, 3, &trans_I1); // C, F, I-C-F
    rmultinom(R1, &prob_R1, 3, &trans_R1); // E, F, R-E-F
    
    rmultinom(S2, &prob_S2, 3, &trans_S2); // B, F, S-B-F
    rmultinom(I2, &prob_I2, 3, &trans_I2); // C, F, I-C-F
    rmultinom(R2, &prob_R2, 3, &trans_R2); // E, F, R-E-F
    
    rmultinom(S3mD, &prob_S3, 2, &trans_S3); // B, (S-D)-B
    rmultinom(I3mD, &prob_I3, 2, &trans_I3); // C, (I-D)-C
    rmultinom(R3mD, &prob_R3, 2, &trans_R3); // E, (R-D)-E
    
    S1 = trans_S1[2] + trans_R1[0] + rpois(4*1025.7); // Include Birth
    I1 = trans_I1[2] + trans_S1[0];
    R1 = trans_R1[2] + trans_I1[0];
    
    S2 = trans_S2[2] + trans_R2[0] + trans_S1[1]; // Include Aging
    I2 = trans_I2[2] + trans_S2[0] + trans_I1[1];
    R2 = trans_R2[2] + trans_I2[0] + trans_R1[1];
    
    S3 = trans_S3[1] + trans_R3[0] + trans_S2[1]; // Include Aging
    I3 = trans_I3[1] + trans_S3[0] + trans_I2[1];
    R3 = trans_R3[1] + trans_I3[0] + trans_R2[1];
    
    //Accumvar
    H1 += trans_S1[0];
    H2 += trans_S2[0];
    H3 += trans_S3[0];
    
    q1 = -1; 
    while(q1 < 0 || q1 > 1){
      q1 = rnorm(0.07, sigma_q);
    }
    
    q2 = -1; 
    while(q2 < 0 || q2 > 1){
      q2 = rnorm(0.07, sigma_q);
    }
    
    q3 = -1; 
    while(q3 < 0 || q3 > 1){
      q3 = rnorm(0.07, sigma_q);
    }
")


# define parameters (without betas)
params_fixed <- c(gamma=1, delta1=1/(5*52),delta2=1/(55*52), alpha=1/(78.86912*52), 
                  mu=0, N=82372825, omega=1/(1*52))
# WWR's rinit
rinit <- Csnippet("
    double m = N/(S10+I10+R10+S20+I20+R20+S30+I30+R30);
    I1=nearbyint(m*I10);
    I2=nearbyint(m*I20);
    I3=nearbyint(m*I30);
    S1=nearbyint(m*S10);
    S2=nearbyint(m*S20);
    S3=nearbyint(m*S30);
    R1=nearbyint(m*R10);
    R2=nearbyint(m*R20);
    R3=nearbyint(m*R30);
    H1 = 0;
    H2 = 0;
    H3 = 0;
")

# Set to MLE
params_stocks_stst_mle <- params_fixed

params_stocks_stst_mle["beta1"] <- 11.48
params_stocks_stst_mle["beta2"] <- 0.25
params_stocks_stst_mle["beta3"] <- 0.35
params_stocks_stst_mle["phi"] <- 0.14
params_stocks_stst_mle["beta11"] <- 0.16
params_stocks_stst_mle["sigma_q"] <- 0.021
params_stocks_stst_mle["sigma_xi"] <- 66.89
params_stocks_stst_mle["S10"] <- 0.047061
params_stocks_stst_mle["I10"] <- 0.000368
params_stocks_stst_mle["R10"] <- 0.015967
params_stocks_stst_mle["S20"] <- 0.015967
params_stocks_stst_mle["I20"] <- 0.000011
params_stocks_stst_mle["R20"] <- 0.003677
params_stocks_stst_mle["S30"] <- 0.237624
params_stocks_stst_mle["I30"] <- 0.000031
params_stocks_stst_mle["R30"] <- 0.001591



pt <- pomp::parameter_trans(
  log = c("beta1","beta2","beta3","sigma_q","sigma_xi"),
  logit=c("beta11"),
  barycentric=c("S10","I10","R10",
                "S20","I20","R20",
                "S30","I30","R30"),
  toEst= pomp::Csnippet("T_phi = logit(phi/(M_2PI));"),
  fromEst= pomp::Csnippet("phi = M_2PI*expit(T_phi);")
)

read.table("real_rotavirus_metadata.txt") %>%
  rbind(data.frame(time=0,cases1=NA,cases2=NA,cases3=NA)) %>%
  arrange(time) -> dat


pomp(data = dat,
     times="time",
     t0=0,
     dmeasure = dmeas,
     rmeasure = rmeas,
     rprocess = discrete_time(step.fun = rproc, delta.t = 1/4),
     statenames = c("S1", "I1", "R1", "H1", 
                    "S2", "I2", "R2", "H2",
                    "S3", "I3", "R3", "H3", 
                    "q1", "q2", "q3"),
     paramnames = names(params_stocks_stst_mle),
     accumvars=c("H1", "H2", "H3"),
     rinit=rinit,
     partrans = pt,
     params = params_stocks_stst_mle
) -> sir

sir_panel <- panelPomp::panelPomp(list(unit1=sir),
                                  shared=NULL,
                                  specific=params_stocks_stst_mle |> 
                                    as.matrix() |>
                                    `colnames<-`("unit1")
)

require(doParallel)
cores <- ncores
registerDoParallel(cores)
mcopts <- list(set.seed=TRUE)

### Next-round code
el <- readRDS("output/round_02/ovov_02_el.rds")
x <- na.omit(el$fits)
score_total = x$logLik
ranking_total = order(score_total, decreasing = TRUE)[1:top_n_fits]

best_fits = dplyr::select(
  x[ranking_total,], -"logLik", -"se"
)

recycle_vec = sort(rep_len(1:top_n_fits, cores))
full_best_fit <- best_fits[recycle_vec, ] 

coef_names <- colnames(full_best_fit)
colnames(full_best_fit) <- gsub(".{7}$","",coef_names)

starting_values <- vector(cores, mode="list")

for(i in 1:cores){
  t(full_best_fit[i, ])  |> 
    as.matrix() |>
    `colnames<-`("unit1") -> starting_values[[i]] 
}

mifs_global <- foreach(i=1:cores,.packages='pomp', .options.multicore=mcopts) %dopar% {
  panelPomp::mif2(
    sir_panel,
    Np = NP_MIF,
    cooling.fraction.50 = 0.5,
    rw.sd = rw_sd(beta1=0.01*sd,beta2=0.01*sd,beta3=0.01*sd,
                  beta11=0.01*sd,phi=0.01*sd,sigma_q=0.01*sd,sigma_xi=0.01*sd,
                  S10=ivp(0.24)*sd,I10=ivp(0.24)*sd,R10=ivp(0.24)*sd,
                  S20=ivp(0.24)*sd,I20=ivp(0.24)*sd,R20=ivp(0.24)*sd,
                  S30=ivp(0.24)*sd,I30=ivp(0.24)*sd,R30=ivp(0.24)*sd),
    cooling.type = "geometric",
    Nmif = NMIF,
    shared.start = numeric(0),
    specific.start = starting_values[[i]],
    block = F
  ) 
}

bake(file = "output/round_03/ovov_mif_03.rds",{ 
  mifs_global
})

bake(file = "output/round_03/ovov_03_el.rds",{
  el <- measlespkg::eval_logLik(mifs_global, ncores = cores, np_pf = NP_MIF, nreps=cores)
  el
})
@



\begin{table}[htbp]
  \centering
  \begin{threeparttable}
    \caption{Maximum likelihood estimation of parameters by PAL for three models \citep{wwr}, and by mif2 algorithm \citep{pomppackagepaper} for the OvOv model.}
    \label{tab:mlebywwr}
    \begin{tabular}{>{\raggedright\arraybackslash}p{2cm} *{3}{>{\centering\arraybackslash}p{1.5cm}} >{\centering\arraybackslash}p{2.5cm}}
      \toprule
      Parameter      & EqEq  & EqOv  & OvOv  & OvOv (\textbf{pomp})$^*$ \\
      \midrule
      \(\beta_1\)    & 12.15 & 12.74 & 11.48 & $\Sexpr{'test'}$\\
      \(\beta_2\)    & 0.22  & 0.21  & 0.25  & $\Sexpr{'test'}$\\
      \(\beta_3\)    & 0.34  & 0.31  & 0.35  & $\Sexpr{'test'}$\\
      \(\phi\)       & 0.017 & 0.14  & 0.14  & $\Sexpr{'test'}$\\
      \(\rho\)       & 0.022 & 0.19  & 0.16  & $\Sexpr{'test'}$\\
      \(\sigma^2_q\) & n/a   & 0.042 & 0.021 & $\Sexpr{'test'}$\\
      \(\sigma_\xi\) & n/a   & n/a   & 66.89 & $\Sexpr{'test'}$\\
      \addlinespace
      \multicolumn{1}{l}{\(S_{10}\)} & \multicolumn{3}{c}{$3876549^*$} & $5885201$\\
      \multicolumn{1}{l}{\(I_{10}\)} & \multicolumn{3}{c}{$30351$}     & $5041$\\
      \multicolumn{1}{l}{\(R_{10}\)} & \multicolumn{3}{c}{$1315221$}   & $721006$\\
      \multicolumn{1}{l}{\(S_{20}\)} & \multicolumn{3}{c}{$57139612$}  & $44546887$\\
      \multicolumn{1}{l}{\(I_{20}\)} & \multicolumn{3}{c}{$871$}       & $22$\\
      \multicolumn{1}{l}{\(R_{20}\)} & \multicolumn{3}{c}{$302852$}    & $26360811$\\
      \multicolumn{1}{l}{\(S_{30}\)} & \multicolumn{3}{c}{$19573727$}  & $4788420$\\
      \multicolumn{1}{l}{\(I_{30}\)} & \multicolumn{3}{c}{$2550$}      & $131$\\
      \multicolumn{1}{l}{\(R_{30}\)} & \multicolumn{3}{c}{$131092$}    & $65306$\\
      \midrule
      \addlinespace
      \textbf{AIC}  & $98866.65$ & $15154.75$ & $13778.08$ & $\Sexpr{'test'}$\\
      \addlinespace
      \bottomrule
    \end{tabular}
    \begin{tablenotes}
      \small
      \item[*] The initial distribution parameter \(\lambda_0 = (S_{10}, I_{10}, R_{10}, S_{20}, I_{20}, R_{20}, S_{30}, I_{30}, R_{30})\) are assumed to be \textbf{fixed} in \cite{wwr}. The results of the estimates of the OvOv (\textbf{pomp}) model are obtained by using the Iterated Filtering algorithm with 3 rounds and 100 iterations, 50,000 particles, and 36 replicates in each round with the top 12 best fits in terms of likelihood chosen to be the starting value for the next round. 
    \end{tablenotes}
  \end{threeparttable}
\end{table}


\bibliography{palcheck.bib}

\end{document}
